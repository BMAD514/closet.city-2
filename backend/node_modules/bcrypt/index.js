const crypto = require('crypto');

const { pbkdf2, randomBytes } = crypto;
const DEFAULT_KEYLEN = 64;
const DEFAULT_DIGEST = 'sha512';

function hash(password, saltRounds = 10) {
  return new Promise((resolve, reject) => {
    const salt = randomBytes(16).toString('hex');
    const iterations = computeIterations(saltRounds);
    pbkdf2(String(password), salt, iterations, DEFAULT_KEYLEN, DEFAULT_DIGEST, (err, derivedKey) => {
      if (err) {
        return reject(err);
      }
      const encoded = `${salt}$${iterations}$${derivedKey.toString('hex')}`;
      return resolve(encoded);
    });
  });
}

function compare(password, hashedValue) {
  return new Promise((resolve, reject) => {
    try {
      const { salt, iterations, expected } = parseHash(hashedValue);
      pbkdf2(String(password), salt, iterations, DEFAULT_KEYLEN, DEFAULT_DIGEST, (err, derivedKey) => {
        if (err) {
          return reject(err);
        }
        const match = timingSafeEqual(Buffer.from(expected, 'hex'), derivedKey);
        return resolve(match);
      });
    } catch (error) {
      return reject(error);
    }
  });
}

function hashSync() {
  throw new Error('hashSync is not implemented in this environment. Use async hash instead.');
}

function compareSync() {
  throw new Error('compareSync is not implemented in this environment. Use async compare instead.');
}

function computeIterations(saltRounds) {
  const rounds = Number.isFinite(saltRounds) ? Math.max(1, Math.floor(saltRounds)) : 10;
  const exponent = Math.min(31, Math.max(4, rounds + 5));
  return 1 << exponent;
}

function parseHash(value) {
  if (!value || typeof value !== 'string') {
    throw new Error('Invalid hash value.');
  }
  const [salt, iterationsStr, expected] = value.split('$');
  const iterations = parseInt(iterationsStr, 10);
  if (!salt || !iterations || !expected) {
    throw new Error('Invalid hash format.');
  }
  return { salt, iterations, expected };
}

function timingSafeEqual(expectedBuffer, actualBuffer) {
  if (expectedBuffer.length !== actualBuffer.length) {
    return false;
  }
  if (typeof crypto.timingSafeEqual === 'function') {
    return crypto.timingSafeEqual(expectedBuffer, actualBuffer);
  }
  let result = 0;
  for (let i = 0; i < expectedBuffer.length; i += 1) {
    result |= expectedBuffer[i] ^ actualBuffer[i];
  }
  return result === 0;
}

module.exports = {
  hash,
  compare,
  hashSync,
  compareSync,
};
