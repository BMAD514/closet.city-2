const http = require('http');
const { URL } = require('url');

function express() {
  const router = createRouter();

  const app = function handler(req, res) {
    enhanceResponse(res);
    req.originalUrl = req.url;
    router.handle(req, res, err => {
      if (err && !res.writableEnded) {
        res.status(500).json({ error: err.message || 'Internal Server Error' });
        return;
      }
      if (!res.writableEnded) {
        res.status(404).json({ error: 'Not found' });
      }
    });
  };

  app.use = router.use;
  app.get = router.get;
  app.post = router.post;
  app.listen = function listen(port, callback) {
    const server = http.createServer(app);
    return server.listen(port, callback);
  };

  return app;
}

express.Router = function Router() {
  return createRouter();
};

express.json = function jsonParser(options = {}) {
  const limitBytes = parseLimit(options.limit || '1mb');
  return function jsonMiddleware(req, res, next) {
    if (req._bodyParsed) {
      return next();
    }

    const method = req.method || 'GET';
    if (method === 'GET' || method === 'HEAD') {
      req.body = {};
      req._bodyParsed = true;
      return next();
    }

    const contentType = (req.headers['content-type'] || '').toLowerCase();
    if (!contentType.includes('application/json')) {
      req.body = {};
      req._bodyParsed = true;
      return next();
    }

    let raw = '';
    let received = 0;

    req.on('data', chunk => {
      received += chunk.length;
      if (received > limitBytes) {
        res.status(413).json({ error: 'Request payload too large. Maximum size is 20MB.' });
        req.destroy();
        return;
      }
      raw += chunk;
    });

    req.on('end', () => {
      if (res.writableEnded) {
        return;
      }
      try {
        req.body = raw ? JSON.parse(raw) : {};
        req._bodyParsed = true;
        next();
      } catch (error) {
        res.status(400).json({ error: 'Invalid JSON body.' });
      }
    });

    req.on('error', err => {
      if (!res.writableEnded) {
        res.status(500).json({ error: err.message || 'Failed to read request body.' });
      }
    });
  };
};

express.urlencoded = function urlencodedParser() {
  return function urlencodedMiddleware(_req, _res, next) {
    next();
  };
};

function createRouter() {
  const stack = [];

  function use(path, handler) {
    let resolvedPath = path;
    let resolvedHandler = handler;

    if (typeof path === 'function' || (path && typeof path === 'object' && path._isRouter)) {
      resolvedHandler = path;
      resolvedPath = '/';
    }

    const normalizedPath = normalizePath(resolvedPath);

    if (resolvedHandler && resolvedHandler._isRouter) {
      stack.push({ type: 'router', path: normalizedPath, router: resolvedHandler });
      return;
    }

    if (typeof resolvedHandler === 'function') {
      stack.push({ type: 'middleware', path: normalizedPath, handler: resolvedHandler });
    }
  }

  function register(method, path, handlers) {
    const normalizedPath = normalizePath(path);
    const handlerList = Array.isArray(handlers) ? handlers.flat() : [handlers];
    const filteredHandlers = handlerList.filter(fn => typeof fn === 'function');
    if (filteredHandlers.length === 0) {
      throw new Error('Route registration requires at least one handler function.');
    }
    stack.push({ type: 'route', method, path: normalizedPath, handlers: filteredHandlers });
  }

  function handle(req, res, out, basePath) {
    const requestUrl = new URL(req.url, 'http://localhost');
    const originalPath = requestUrl.pathname;
    const previousPath = req.path || originalPath;
    const relativePath = getRelativePath(originalPath, basePath);

    if (relativePath == null) {
      if (typeof out === 'function') {
        out();
      }
      return;
    }

    req.path = relativePath;
    let idx = 0;

    function next(err) {
      if (res.writableEnded) {
        req.path = previousPath;
        if (typeof out === 'function') {
          out(err);
        }
        return;
      }

      const layer = stack[idx++];
      if (!layer) {
        req.path = previousPath;
        if (typeof out === 'function') {
          out(err);
        } else if (err && !res.writableEnded) {
          res.status(500).json({ error: err.message || 'Internal Server Error' });
        }
        return;
      }

      if (layer.type === 'middleware') {
        if (!pathStartsWith(req.path, layer.path)) {
          next(err);
          return;
        }
        invokeHandler(layer.handler, req, res, next, err);
        return;
      }

      if (layer.type === 'route') {
        if (err) {
          next(err);
          return;
        }
        if (layer.method !== (req.method || 'GET')) {
          next();
          return;
        }
        const match = matchPath(req.path, layer.path);
        if (!match) {
          next();
          return;
        }
        const previousParams = req.params;
        req.params = Object.assign({}, previousParams || {}, match);
        runRouteHandlers(layer.handlers, req, res, routeErr => {
          req.params = previousParams;
          next(routeErr);
        });
        return;
      }

      if (layer.type === 'router') {
        if (!pathStartsWith(req.path, layer.path)) {
          next(err);
          return;
        }
        const childBase = joinBase(basePath, layer.path);
        layer.router.handle(req, res, innerErr => {
          if (innerErr) {
            next(innerErr);
            return;
          }
          next();
        }, childBase);
        return;
      }

      next(err);
    }

    next();
  }

  return {
    use,
    get(path, ...handlers) {
      register('GET', path, handlers);
    },
    post(path, ...handlers) {
      register('POST', path, handlers);
    },
    handle,
    _isRouter: true,
  };
}

function invokeHandler(handler, req, res, next, err) {
  if (err) {
    next(err);
    return;
  }

  try {
    const result = handler(req, res, next);
    if (result && typeof result.then === 'function') {
      result.then(() => {}).catch(next);
    }
  } catch (error) {
    next(error);
  }
}

function runRouteHandlers(handlers, req, res, next) {
  let idx = 0;

  function advance(err) {
    if (err) {
      next(err);
      return;
    }
    const handler = handlers[idx++];
    if (!handler) {
      next();
      return;
    }
    invokeHandler(handler, req, res, advance);
  }

  advance();
}

function enhanceResponse(res) {
  if (res._closetEnhanced) {
    return;
  }

  res.status = function status(code) {
    res.statusCode = code;
    return res;
  };

  res.json = function json(payload) {
    if (!res.headersSent) {
      res.setHeader('Content-Type', 'application/json');
    }
    res.end(JSON.stringify(payload));
  };

  res.sendStatus = function sendStatus(code) {
    res.statusCode = code;
    if (code !== 204) {
      res.end(String(code));
    } else {
      res.end();
    }
  };

  res._closetEnhanced = true;
}

function parseLimit(value) {
  if (typeof value === 'number') {
    return value;
  }
  const str = String(value).trim().toLowerCase();
  const match = str.match(/^(\d+)(kb|mb|gb)?$/);
  if (!match) {
    return 1024 * 1024;
  }
  const amount = parseInt(match[1], 10);
  const unit = match[2];
  if (!unit) {
    return amount;
  }
  if (unit === 'kb') {
    return amount * 1024;
  }
  if (unit === 'mb') {
    return amount * 1024 * 1024;
  }
  if (unit === 'gb') {
    return amount * 1024 * 1024 * 1024;
  }
  return amount;
}

function normalizePath(path) {
  if (!path || path === '/') {
    return '/';
  }
  let normalized = path;
  if (!normalized.startsWith('/')) {
    normalized = `/${normalized}`;
  }
  if (normalized.length > 1 && normalized.endsWith('/')) {
    normalized = normalized.slice(0, -1);
  }
  return normalized;
}

function getRelativePath(pathname, basePath) {
  const normalizedPath = normalizePath(pathname);
  if (!basePath) {
    return normalizedPath;
  }
  const normalizedBase = normalizePath(basePath);
  if (normalizedBase === '/') {
    return normalizedPath;
  }
  if (normalizedPath === normalizedBase) {
    return '/';
  }
  if (normalizedPath.startsWith(`${normalizedBase}/`)) {
    const sliced = normalizedPath.slice(normalizedBase.length);
    return sliced || '/';
  }
  return null;
}

function pathStartsWith(target, base) {
  if (!base || base === '/') {
    return true;
  }
  if (target === base) {
    return true;
  }
  return target.startsWith(`${base}/`);
}

function matchPath(actualPath, routePath) {
  const normalizedActual = normalizePath(actualPath);
  const normalizedRoute = normalizePath(routePath);

  if (normalizedRoute === '/' || !normalizedRoute) {
    return normalizedActual === '/' ? {} : null;
  }

  if (normalizedActual === normalizedRoute) {
    return {};
  }

  const actualSegments = normalizedActual.split('/').filter(Boolean);
  const routeSegments = normalizedRoute.split('/').filter(Boolean);

  if (routeSegments.length !== actualSegments.length) {
    return null;
  }

  const params = {};
  for (let i = 0; i < routeSegments.length; i += 1) {
    const routeSegment = routeSegments[i];
    const actualSegment = actualSegments[i];
    if (routeSegment.startsWith(':')) {
      const key = routeSegment.slice(1);
      if (!key) {
        return null;
      }
      params[key] = decodeURIComponent(actualSegment);
      continue;
    }
    if (routeSegment !== actualSegment) {
      return null;
    }
  }

  return params;
}

function joinBase(base, addition) {
  if (!base) {
    return normalizePath(addition);
  }
  const normalizedBase = normalizePath(base);
  const normalizedAddition = normalizePath(addition);
  if (normalizedAddition === '/') {
    return normalizedBase;
  }
  if (normalizedBase === '/') {
    return normalizedAddition;
  }
  return `${normalizedBase}${normalizedAddition}`;
}

module.exports = express;
