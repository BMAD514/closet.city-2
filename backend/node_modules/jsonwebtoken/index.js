const crypto = require('crypto');

function sign(payload, secret, options = {}) {
  if (!secret) {
    throw new Error('JWT secret is required.');
  }

  const header = { alg: 'HS256', typ: 'JWT' };
  const issuedAt = Math.floor(Date.now() / 1000);
  const claims = { ...payload, iat: issuedAt };

  if (options.expiresIn) {
    claims.exp = issuedAt + parseExpiry(options.expiresIn);
  }

  const encodedHeader = base64UrlEncode(JSON.stringify(header));
  const encodedPayload = base64UrlEncode(JSON.stringify(claims));
  const signature = createSignature(`${encodedHeader}.${encodedPayload}`, secret);

  return `${encodedHeader}.${encodedPayload}.${signature}`;
}

function verify(token, secret) {
  if (!token || typeof token !== 'string') {
    throw new Error('Invalid token format.');
  }
  const parts = token.split('.');
  if (parts.length !== 3) {
    throw new Error('Invalid token structure.');
  }
  const [encodedHeader, encodedPayload, signature] = parts;
  const expectedSignature = createSignature(`${encodedHeader}.${encodedPayload}`, secret);
  if (!timingSafeEqual(Buffer.from(signature), Buffer.from(expectedSignature))) {
    throw new Error('Invalid signature.');
  }
  const payload = JSON.parse(base64UrlDecode(encodedPayload));
  if (payload.exp && Math.floor(Date.now() / 1000) >= payload.exp) {
    throw new Error('Token expired.');
  }
  return payload;
}

function parseExpiry(value) {
  if (typeof value === 'number') {
    return value;
  }
  const match = /^([0-9]+)([smhd])$/.exec(String(value).trim());
  if (!match) {
    throw new Error('Unsupported expiresIn format.');
  }
  const amount = parseInt(match[1], 10);
  const unit = match[2];
  switch (unit) {
    case 's':
      return amount;
    case 'm':
      return amount * 60;
    case 'h':
      return amount * 3600;
    case 'd':
      return amount * 86400;
    default:
      throw new Error('Unsupported expiresIn unit.');
  }
}

function base64UrlEncode(input) {
  return Buffer.from(input).toString('base64').replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
}

function base64UrlDecode(input) {
  const padded = input.padEnd(input.length + ((4 - (input.length % 4)) % 4), '=');
  const base64 = padded.replace(/-/g, '+').replace(/_/g, '/');
  return Buffer.from(base64, 'base64').toString('utf8');
}

function createSignature(content, secret) {
  return crypto.createHmac('sha256', secret).update(content).digest('base64').replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
}

function timingSafeEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  return crypto.timingSafeEqual(a, b);
}

module.exports = {
  sign,
  verify,
};
